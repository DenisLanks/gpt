/*
 *   Copyright (C) 2003-2006 by Thiago Silva                               *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */


header {
  #include "BasePortugolParser.hpp"
  #include "GPTDisplay.hpp"
  #include "GASMFE_CAsmProgram.hpp"
  #include "GASMFE_COptions.hpp"
  #include "CTemporarySymbol.hpp"
  #include "SymbolTable.hpp"
  #include "Tools.hpp"
  #include <stdlib.h>
}

options {
  language="Cpp";  
}

{
}

class PortugolParser extends Parser("BasePortugolParser");

options {
  importVocab=Portugol;  // use vocab generated by lexer
  genHashLines=false;//no #line
  k=3;
}

{  
   public:
      COptions options;
      CAsmProgram  *asmPrg;
      CSubroutine *subroutine;
      CTemporarySymbol tempVar;
      CTemporarySymbol tempLabel;
      SymbolTable symbolTable;
      void initParser( string filename )
      {
         options.filename = filename;
//         options.sourcefile = filename + ".gpt";
//         options.destfile   = filename + ".gasm";
         asmPrg = new CAsmProgram( &options, &symbolTable );
         tempVar.setBaseName( "__temp_" );
         tempVar.setNextValue( 1 );
         tempLabel.setBaseName( "__label_" );
      }
      void finishParser( )
      {
         delete asmPrg;
         asmPrg = NULL;
      }
      void declareProgramVar(const string& scope, const string& lexeme, int line, int type)
      {
         symbolTable.declareVar( scope, lexeme, line, type );
         asmPrg->emitVarDefinition( lexeme, type );
      }
      void declareSubroutineVar(const string& scope, const string& lexeme, int line, int type)
      {
         symbolTable.declareVar( scope, lexeme, line, type );
         subroutine->emitVarDefinition( lexeme, type );
      }
      void declareParameter(const string& lexeme, int line, int type)
      {
         symbolTable.declareVar( subroutine->getName(), lexeme, line, type );
         subroutine->emitParDefinition( lexeme, type );
      }
      int getSymbolType( const string& lexeme )
      {
         return symbolTable.getSymbol(subroutine->getName(), lexeme, true).getType().getPrimitiveType();
      }
//      string getAsmProgram( ) const
//      {
//         return asmPrg->getAsm( );
//      }
}


//####################################################################
//####################### Início da gramática ########################
//####################################################################

//##############
//## Programa ##
//##############

//--------
  programa [string filename] returns [string ret]
//-------- 
  : { initParser( filename ); asmPrg->init( ); } (declaracao_algoritmo)? (importacao)*
    (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis[false])* corpo EOF
    {
       asmPrg->finish( );
       ret = asmPrg->getAsm( );
       finishParser( );
    }
  ;

declaracao_algoritmo
  : "algoritmo" T_IDENTIFICADOR T_SEMICOL
  ;

importacao
  : "use" T_STRING_LIT T_SEMICOL
  ;

corpo 
  :  (declaracao_subrotina)* { subroutine = asmPrg->initSubroutine( "main" ); }
     bloco_codigo { asmPrg->finishSubroutine( subroutine ); }
     (declaracao_subrotina)*
  ;


//#############################
//## Declaração de variáveis ##
//#############################

//--------------------
  declaracao_variaveis [bool isLocal]
//--------------------
  : bloco_declaracao_variaveis[isLocal]
  | "variável" declaracao_variavel[isLocal]
  ;

bloco_declaracao_variaveis [bool isLocal]
  : "variáveis" (declaracao_variavel[isLocal])+ "fim-variáveis"
  ;

declaracao_variavel [bool isLocal]
{
  int tk_type;
}
  : tk_id:T_IDENTIFICADOR 
    (T_COMMA T_IDENTIFICADOR)* 
    //T_COLON tipo {tk_type = lastToken; }
    T_COLON tk_type=tipo
    (lista_inicializacao)? T_SEMICOL
    { // TODO: nao esta correto porque so gera uma variavel...
       if (isLocal) {
          declareSubroutineVar( SymbolTable::GlobalScope, tk_id->getText( ), 0, tk_type );
       } else {
          declareProgramVar( SymbolTable::GlobalScope, tk_id->getText( ), 0, tk_type );
       }
    }
  ;

//declaracao_variavel_sing
//{
//  int type;
//}
//  : T_IDENTIFICADOR T_COLON type=tipo (lista_inicializacao)? T_SEMICOL
//  ;

tipo returns [int ret]
  : ret=tipo_primitivo 
  | ret=tipo_matriz 
  | T_IDENTIFICADOR {ret=T_KW_ESTRUTURA;}
  ;

lista_inicializacao
{
  string result;
}
  : T_ATTR (result=expr | inicializacao_composta)
  ;

inicializacao_composta
  : T_ABREC inicializacao_indice (T_COLON inicializacao_indice)* T_FECHAC
//  | "{" (inicializacao_membro) (T_COLON inicializacao_membro)* "}"
  ;

inicializacao_indice
{
  string result;
}
  : result=expr
//  : (result=expr | inicializacao_composta)
  ;

inicializacao_membro
{
  string result;
}
  : T_IDENTIFICADOR T_ATTR (result=expr | inicializacao_composta)
  ;

tipo_primitivo returns [int ret]
  : "inteiro"   {ret=T_KW_INTEIRO;}
  | "real"      {ret=T_KW_REAL;}
  | "caractere" {ret=T_KW_CARACTERE;}
  | "literal"   {ret=T_KW_LITERAL;}
  | "lógico"    {ret=T_KW_LOGICO;}
  | "coringa"   {ret=T_KW_CORINGA;}
  ;

tipo_matriz returns [int ret]
{
  int type;
}
  : "matriz" (T_ABREC (T_INT_LIT)? T_FECHAC)+ "do" "tipo" (type=tipo_primitivo | T_IDENTIFICADOR)
    {ret=T_KW_MATRIZ;}
  ;


/****************************************************************************/
declaracao_constantes
  : bloco_declaracao_constantes
  | "constante" declaracao_constante
  ;

bloco_declaracao_constantes
  : "constantes" (declaracao_constante)+ "fim-constantes"
  ;

declaracao_constante
{
  int type;
}
  : T_IDENTIFICADOR T_COLON type=tipo lista_inicializacao T_SEMICOL
  ;


/****************************************************************************/
bloco_declaracao_estrutura
  : "estrutura" T_IDENTIFICADOR (declaracao_variavel[false])+ "fim-estrutura"
  ;


/****************************************************************************/
declaracao_subrotina
  : declaracao_funcao
  | declaracao_procedimento
  ;

declaracao_funcao
{
   int tk_type;
}
//  : "função" T_IDENTIFICADOR "(" (lista_parametros)? ")" ":" tipo
  : "função" tk_id:T_IDENTIFICADOR
    { subroutine = asmPrg->initSubroutine( tk_id->getText( ) ); }
    T_ABREP (lista_parametros)? T_FECHAP T_COLON tk_type=tipo
    {
       declareSubroutineVar( SymbolTable::GlobalScope, "__result", 0, tk_type );
    }
    (declaracao_constantes | declaracao_variaveis[true])*
    bloco_codigo
    { asmPrg->finishSubroutine( subroutine ); }
  ;

declaracao_procedimento
  //: "procedimento" T_IDENTIFICADOR "(" (lista_parametros)? ")"
  : "procedimento" tk_id:T_IDENTIFICADOR
    { subroutine = asmPrg->initSubroutine( tk_id->getText( ) ); }
    T_ABREP (lista_parametros)? T_FECHAP
    (declaracao_constantes | declaracao_variaveis[true])*
    bloco_codigo
    { asmPrg->finishSubroutine( subroutine ); }
  ;

lista_parametros
  : parametro (T_COMMA parametro)*
  ;

parametro
{
  int type;
}
  : (("constante")? ("ref"))? tk_id:T_IDENTIFICADOR T_COLON type=tipo
  {
    declareParameter( tk_id->getText( ), 0, type );
  }
  ;

/****************************************************************************/
bloco_codigo
  : "início" lista_enunciados "fim"
  ;

lista_enunciados
  : (enunciado)*
  ;

enunciado
  :
  ( (lvalue T_ATTR)=> en_atribuicao
    | en_retorne
    | en_se
    | en_enquanto
    | en_repita
    | en_para
    | en_caso
    | en_asm_code
    | chamada_procedimento
//    | expr
    | "sair" T_SEMICOL
    | T_SEMICOL
  )
// Nao eh tao simples assim de resolver. E se outra temp tiver o mesmo nome mas tipo diferentes ???
// Uma solucao talvez seja cada temporaria tem baseName formado pelo seu tipo tambem.
//  { tempVar.setNextValue(1); }
  ;

en_atribuicao
{
   string tklvalue;
   string tkexpret;
}
  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
//  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
//  : (lvalue T_ATTR)=> stm_attr {tkexpret=lastToken;} T_SEMICOL
    { subroutine->emitMnWithPrefix( "set", tklvalue, tkexpret ); }
  ;

//stm_attr
//  : lvalue T_ATTR expr
//  ;

en_retorne
{
  string result;
}
  : "retorne"
    (result=expr {subroutine->emitMnWithPrefix( "set", "__result", result ); } )?
    { subroutine->emitMn( "ret" ); }
    T_SEMICOL
  ;

lvalue returns [string tk_id]
{
  string ret;
}
  : T_IDENTIFICADOR {tk_id=lastToken->getText( );}
    (T_ABREC ret=expr T_FECHAC)*
  | T_IDENTIFICADOR T_DOT T_IDENTIFICADOR
  ;

en_se
{
  string expRet;
  string elseLabel;
  string nextLabel;
}
  : "se" expRet=expr "então" { elseLabel = tempLabel.getNew( ); subroutine->emitMn( "ifnot", expRet, elseLabel ); }
    lista_enunciados
    { nextLabel = tempLabel.getNew( ); subroutine->emitMn( "jmp", nextLabel ); subroutine->emitLabel( elseLabel ); }
    ("senão" lista_enunciados)? "fim-se"
    { subroutine->emitLabel( nextLabel ); }
  ;

en_enquanto
{
  string testLabel;
  string expRet;
  string nextCommandLabel;
}
  : "enquanto"
    {
       testLabel = tempLabel.getNew( );
       nextCommandLabel = tempLabel.getNew( );
       subroutine->emitLabel( testLabel );
    }
    expRet=expr "faça"
    {
       subroutine->emitMn( "ifnot", expRet, nextCommandLabel );
    }
    lista_enunciados
    "fim-enquanto"
    {
       subroutine->emitMn( "jmp", testLabel );
       subroutine->emitLabel( nextCommandLabel );
    }
  ;

en_para
{
  string lvalueRet;
  string exp1;
  string exp2;
  string testLabel;
  string nextCommandLabel;
  string testVar;
  int    step=1;
}
  : "para" lvalueRet=lvalue "de" exp1=expr "até" exp2=expr (step=passo)? "faça"
    {
       subroutine->emitMnWithPrefix( "set", lvalueRet, exp1 );
       testLabel = tempLabel.getNew( );
       nextCommandLabel = tempLabel.getNew( );
       testVar   = tempVar.getNew( );
       declareSubroutineVar( SymbolTable::GlobalScope, testVar, 0, T_KW_INTEIRO );
       subroutine->emitLabel( testLabel );
       if (step >= 0) {
          subroutine->emitMnWithPrefix( "le", testVar, lvalueRet, exp2 );
       } else {
          subroutine->emitMnWithPrefix( "ge", testVar, lvalueRet, exp2 );
       }
       subroutine->emitMn( "ifnot", testVar, nextCommandLabel );
    }
    lista_enunciados
    "fim-para"
    {
       subroutine->emitMnWithPrefix( step > 0 ? "inc" : "dec", lvalueRet, itoa( abs( step ) ) );
       subroutine->emitMn( "jmp", testLabel );
       subroutine->emitLabel( nextCommandLabel );
    }
  ;

passo returns [int ret]
{
  string signal;
}
  : "passo" (T_MAIS|T_MENOS{signal="-";})? T_INT_LIT { ret=atoi((signal+lastToken->getText( )).c_str( )); }
  ;

//en_repita
//  : ("repita" lista_enunciados "enquanto") => en_repita_enquanto
//  | ("repita" lista_enunciados "até") => en_repita_ate
//  ;

en_repita
{
  string labelBegin = tempLabel.getNew( );
  string exp;
}
  : "repita"
    { subroutine->emitLabel( labelBegin ); }
    lista_enunciados
    "até" exp=expr
    { subroutine->emitMn( "ifnot", exp, labelBegin ); }
  ;

//en_repita_enquanto
//  : "repita" lista_enunciados "enquanto" expr T_SEMICOL
//  ;

//en_repita_ate
//  : "repita" lista_enunciados "até" expr T_SEMICOL
//  ;

//en_repita
//  : "repita" lista_enunciados "até" expr
//  ;

en_caso 
{
  string expret;
  string varTest;
  string nextCommandLabel;
  string nextTestLabel;
}
  : "caso" expret=expr "seja" 
    {
       varTest = tempVar.getNew( );
       declareSubroutineVar( SymbolTable::GlobalScope, varTest, 0, T_KW_INTEIRO );
       subroutine->emitMnWithPrefix( "set", varTest, expret );
       nextCommandLabel = tempLabel.getNew( );
    }
    (
       nextTestLabel=teste_caso[varTest]
       {subroutine->emitMn( "jmp", nextCommandLabel ); subroutine->emitLabel( nextTestLabel );}
    )+ ("senão" lista_enunciados "fim-senão")? "fim-caso" 
    {
       subroutine->emitLabel( nextCommandLabel );
    }
  ; 
  
teste_caso [string varTest] returns [string nextTestLabel]
{
  string lit;
}
  : lit=literal "faça" 
    {
       declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew(), 0, getSymbolType( varTest ) );
       subroutine->emitMnWithPrefix( "eq", tempVar.getLast(), varTest, lit );
       nextTestLabel = tempLabel.getNew( );
       subroutine->emitMn( "ifnot", tempVar.getLast( ), nextTestLabel );
    }
    lista_enunciados
    "fim-faça"
  ;

en_asm_code
//  : ASM_CODE { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
  : "asm"
    T_ASM_CODE { subroutine->emitAsmCode( lastToken->getText( ) ); }
    "fim-asm"
//(
//       ~("fim-asm") { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
//    )*
//    "fim-asm"
  ;

//en_asm_code
////  : ASM_CODE { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
//  : "asm"
//    (
//       ~("fim-asm") { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
//    )*
//    "fim-asm"
//  ;

/****************************************************************************/
chamada_procedimento
{
   CArguments args;
}
  : tk_id:T_IDENTIFICADOR T_ABREP
    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos[args] { args.emitMnsInSubroutineCall( ); })? T_FECHAP
    { subroutine->emitMn( "pcall", tk_id->getText( ) ); }
  ; 

chamada_funcao returns [string ret]
{
   CArguments args;
}
  : tk_id:T_IDENTIFICADOR T_ABREP
    { subroutine->emitMn( "push_0" ); }
    ( 
      { args.init( subroutine, tk_id->getText( ) ); }
      lista_argumentos[args]
      { args.emitMnsInSubroutineCall( ); }
    )? T_FECHAP
    {
      subroutine->emitMn( "pcall", tk_id->getText( ) );
      ret = tempVar.getNew( );
      declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, T_KW_INTEIRO );
      subroutine->emitMn( "pop", ret );
    }
  ; 

lista_argumentos [CArguments &args]
{
  string ret;
}
  // TODO: a gente poderia sempre adicionar o token (string) retornado por expr. Na tabela de simbolos
  // vao existir TODOS os simbolos. Com isso sera facil identificar o tipo (para push_<type>) 
  // sem necessitar de RefToken.
  : ret=expr { args.push_back( ret ); }
    (
      T_COMMA ret=expr
      { args.push_back( ret ); }
    )*
  ;

//lista_argumentos
//{
//   RefToken exp;
//}
//  : expr { args.push_back( lastToken ); }
//    (T_COMMA expr { args.push_back( lastToken ); } )*
//  ;

literal returns [string ret]
  : ( 
        T_STRING_LIT {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LITERAL );}
      | T_INT_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_INTEIRO );}
      | T_REAL_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_REAL );}
      | T_CARAC_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_CARACTERE );}
      | "verdadeiro"  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LOGICO );} // ???
      | "falso"  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LOGICO );}      // ???
    ) {ret=lastToken->getText( );}
  ;

/* ----------------------------- Expressoes ---------------------------------- */

expr returns [string ret]
{
  string op2;
}
  : ret=expr_e 
    (
      T_KW_OU op2=expr_e 
      {
         subroutine->emitMn( "or", tempVar.getNew( ), ret, op2 );
         ret=tempVar.getLast( );
         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
      }
    )*
  ;
  
expr_e  returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_bit_ou
    (
      T_KW_E op2=expr_bit_ou
      {
         subroutine->emitMn( "and", tempVar.getNew( ), ret, op2 );
         ret=tempVar.getLast( );
         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
      }
    )*
  ;

expr_bit_ou returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_bit_xou
    (
      T_BIT_OU op2=expr_bit_xou
      {
         subroutine->emitMn( "bor", tempVar.getNew( ), ret, op2 );
         ret=tempVar.getLast( );
         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
      }
    )*
  ;

expr_bit_xou  returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_bit_e 
    (
      T_BIT_XOU op2=expr_bit_e
      {
         subroutine->emitMn( "bxor", tempVar.getNew( ), ret, op2 );
         ret=tempVar.getLast( );
         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
      }
    )*
  ;

expr_bit_e returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_igual
    (
      T_BIT_E op2=expr_igual
      {
         subroutine->emitMn( "band", tempVar.getNew( ), ret, op2 );
         ret=tempVar.getLast( );
         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
      }
    )*
  ;
  
expr_igual returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
  string mn;
}
  : ret=expr_relacional
    (
      ( T_IGUAL {mn="eq";} | T_DIFERENTE {mn="ne";} )
      op2=expr_relacional
      {
//         subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
//         ret=tempVar.getLast( );
//         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
         ret=tempVar.getLast( );
      }
    )*
  ;
        
expr_relacional returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
  string mn;
}
  : ret=expr_ad 
    (
      ( T_MAIOR {mn="gt";} | T_MAIOR_EQ {mn="ge";} | T_MENOR {mn="lt";} | T_MENOR_EQ {mn="le";} )
      op2=expr_ad
      {
         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
         //ret=tempVar.getLast( );
         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
         ret=tempVar.getLast( );
      }
    )*
  ;

expr_ad returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
   string op2;
   string mn;
}
  : ret=expr_multip 
    (
      ( T_MAIS {mn="sum";} | T_MENOS {mn="sub";} )
      op2=expr_multip
      {
         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
         //ret=tempVar.getLast( );
         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
         ret=tempVar.getLast( );
      }
    )*
  ;

expr_multip returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
  string mn;
}
  : ret=expr_unario
    (
      ( T_DIV {mn="div";} | T_MULTIP {mn="mul";} | T_MOD {mn="mod";} )
      op2=expr_unario
      {
         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
         //ret=tempVar.getLast( );
         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType(op2) );
         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
         ret=tempVar.getLast( );
      } 
    )*
  ;

expr_unario returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  //: op_unario ret=expr_elemento
  : ret=expr_elemento
  ;

op_unario
  : (
        e:T_MENOS
      | a:T_MAIS
      | n:T_KW_NOT
      | b:T_BIT_NOT
    )?
  ; 

expr_elemento returns [string ret]
  : (T_IDENTIFICADOR T_ABREP)=> ret=chamada_funcao
  | ret=lvalue
  | ret=literal
  | t:T_ABREP ret=expr T_FECHAP 
  ;

