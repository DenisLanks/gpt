/*
 *   Copyright (C) 2003-2006 by Thiago Silva                               *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */


header {
  #include "BasePortugolParser.hpp"
  #include "GPTDisplay.hpp"
  #include "GASMFE_CAsmProgram.hpp"
  #include "GASMFE_COptions.hpp"
}

options {
  language="Cpp";  
}

{
}

class PortugolParser extends Parser("BasePortugolParser");

options {
  importVocab=Portugol;  // use vocab generated by lexer
  genHashLines=false;//no #line
  k=2;
}

{  
//  public:
//    RefPortugolAST getPortugolAST()
//    {
//      return returnAST;
//    }
   public:
      COptions options;
      CAsmProgram  *asmPrg;
      CSubroutine *subroutine;
      CArguments args;
      void initParser( )
      {
         options.sourcefile = "xxx.gpt";
         options.destfile   = "xxx.gasm";
         asmPrg = new CAsmProgram( &options );
      }
      void finishParser( )
      {
         delete asmPrg;
         asmPrg = NULL;
      }
}




/******************************** GRAMATICA *************************************************/

/*algoritmo
  : declaracao_algoritmo (var_decl_block)? stm_block (func_decls)* EOF
  ;

  exception //nem "variaveis" nem "inicio"
  catch[antlr::NoViableAltException e] {
    reportParserError(e.getLine(), 
      "\"variáveis\" ou \"início\" após declaração de algoritmo", getTokenDescription(e.token));
  }

  catch[antlr::MismatchedTokenException e] { //EOF
    reportParserError(e.getLine(), expecting_eof_or_function, getTokenDescription(e.token));
  }
*/

programa 
  : { initParser( ); } (declaracao_algoritmo)? (importacao)*
    (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis)* corpo EOF
    { finishParser( ); }
  ;

declaracao_algoritmo
  : "algoritmo" T_IDENTIFICADOR T_SEMICOL
  ;

importacao
  : "use" T_STRING_LIT T_SEMICOL
  ;

corpo 
  :  (declaracao_subrotina)* { subroutine = asmPrg->initSubroutine( "main" ); }
     bloco_codigo { asmPrg->finishSubroutine( subroutine ); }
     (declaracao_subrotina)*
  ;


/****************************************************************************/
declaracao_variaveis
  : bloco_declaracao_variaveis
  | "variável" declaracao_variavel T_SEMICOL
  ;

bloco_declaracao_variaveis
  : "variáveis" (declaracao_variavel)+ "fim-variáveis"
  ;

declaracao_variavel
  : T_IDENTIFICADOR (T_COMMA T_IDENTIFICADOR)* T_COLON tipo (lista_inicializacao)? T_SEMICOL
  ;

declaracao_variavel_sing
  : T_IDENTIFICADOR T_COLON tipo (lista_inicializacao)? T_SEMICOL
  ;

tipo 
  : tipo_primitivo 
  | tipo_matriz 
  | T_IDENTIFICADOR
  ;

lista_inicializacao
  : T_ATTR (expressao | inicializacao_composta)
  ;

inicializacao_composta
  : "[" (inicializacao_indices) (T_COLON inicializacao_indices)* "]"
  | "{" (inicializacao_membros) (T_COLON inicializacao_membros)* "}"
  ;

inicializacao_indices
  : (expressao | inicializacao_composta)
  ;

inicializacao_membros
  : T_IDENTIFICADOR T_ATTR (expressao | inicializacao_composta)
  ;

tipo_primitivo
  : "inteiro"
  | "real"
  | "caractere"
  | "literal"
  | "lógico"
  | "coringa"
  ;

tipo_matriz
  : "matriz" ("[" (T_INT_LIT)? "]")+ "do" "tipo" (tipo_primitivo | T_IDENTIFICADOR)
  ;


/****************************************************************************/
declaracao_constantes
  : bloco_declaracao_constantes
  | "constante" declaracao_constante T_SEMICOL
  ;

bloco_declaracao_constantes
  : "constantes" (declaracao_constante)+ "fim-constantes"
  ;

declaracao_constante
  : T_IDENTIFICADOR T_COLON tipo lista_inicializacao T_SEMICOL
  ;


/****************************************************************************/
bloco_declaracao_estrutura
  : "estrutura" T_IDENTIFICADOR (declaracao_variavel)+ "fim-estrutura"
  ;


/****************************************************************************/
declaracao_subrotina
  : declaracao_funcao
  | declaracao_procedimento
  ;

declaracao_funcao
//  : "função" T_IDENTIFICADOR "(" (lista_parametros)? ")" ":" tipo
  : "função" T_IDENTIFICADOR "(" ")" T_COLON tipo
    (declaracao_constantes | declaracao_variaveis)*
    bloco_codigo
  ;

declaracao_procedimento
  //: "procedimento" T_IDENTIFICADOR "(" (lista_parametros)? ")"
  : "procedimento" T_IDENTIFICADOR "(" ")"
    (declaracao_constantes | declaracao_variaveis)*
    bloco_codigo
  ;

//lista_parametros
//  : ( ("constante")? "ref")? T_IDENTIFICADOR T_COLON tipo (T_COMMA lista_parametros)*
//  ;


/****************************************************************************/
bloco_codigo
  : "início" lista_enunciados "fim"
  ;

lista_enunciados
  : (enunciado)*
  ;

enunciado
  : en_atribuicao
  | en_retorne
  | en_se
  | en_enquanto
  | en_repita
  | en_para
  | en_caso
  | en_asm
  | expressao
  | "sair" T_SEMICOL
  | T_SEMICOL
  ;

en_atribuicao
{
   RefToken tklvalue;
   RefToken tkexpret;
}
  : tklvalue=lvalue T_ATTR tkexpret=expressao T_SEMICOL
    { subroutine->emitISETMn( tklvalue->getText( ), tkexpret->getText( ) ); }
  ;

en_retorne
  : "retorne" (expressao)? T_SEMICOL
  ;

lvalue returns [RefToken tk_id]
  : T_IDENTIFICADOR {tk_id=lastToken;} //(T_ABREC expressao T_FECHAC)*
  ;

en_se
  : "se" expressao "então" lista_enunciados ("senão" lista_enunciados)? "fim-se"
  ;

en_enquanto
  : "enquanto" expressao "faça" lista_enunciados "fim-enquanto"
  ;

en_para
  : "para" lvalue "de" expressao "até" expressao (passo)? "faça" lista_enunciados "fim-para"
  ;

passo
  : "passo" (T_MAIS|T_MENOS)? T_INT_LIT
  ;

//en_repita
//  : "repita" lista_enunciados "enquanto" expressao
//  | "repita" lista_enunciados "até" expressao
//  ;

en_repita
  : "repita" lista_enunciados "até" expressao
  ;

en_caso 
  : "caso" expressao "seja" (teste_caso)+ ("senão" lista_enunciados "fim-senão")? "fim-caso" 
  ; 
  
teste_caso
  : literal "faça" lista_enunciados "fim-faça"
  ;

en_asm
  : "asm" (~("fim-asm"))* "fim-asm"
  ;


/****************************************************************************/
expressao returns [RefToken tk_ret]
  : termo {tk_ret=lastToken;} //T_BIT_E termo
  ;

/*
expressao
  : termo "|" termo
  | termo "^" termo
  | termo "&" termo
  | termo ">>" termo 
  | termo "<<" termo
  | termo ("ou" | "||") termo
  | termo ("e" | "&&") termo
  | termo ("=" | "<>") termo
  | termo (">" | ">="|"<"|"<=") termo
  | termo ("+" | "-") termo
  | termo ("/" | "*" | "%") termo
  | ("+" | "-" | "~" | "não")? termo
  | "(" termo ")"
  | chamada_subrotina
  ;
*/

/*expressao
  : expressao "|" expressao
  | expressao "^" expressao
  | expressao "&" expressao
  | expressao ">>" expressao 
  | expressao "<<" expressao
  | expressao ("ou" | "||") expressao
  | expressao ("e" | "&&") expressao
  | expressao ("=" | "<>") expressao
  | expressao (">" | ">="|"<"|"<=") expressao
  | expressao ("+" | "-") expressao
  | expressao ("/" | "*" | "%") expressao
  | ("+" | "-" | "~" | "não")? termo
  ;
*/


termo returns [RefToken tk_ret]
  : tk_ret=lvalue
  | literal { tk_ret = lastToken; }
  | chamada_subrotina
  ;

//termo
//  : chamada_subrotina
//  | lvalue
//  | literal
////  | "(" expressao ")"
//  ;

chamada_subrotina
  : tk_id:T_IDENTIFICADOR T_ABREP
    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos { args.emitMnsInSubroutineCall( ); })? T_FECHAP
    { subroutine->emitPCALLMn( tk_id->getText( ) ); }
  ; 

lista_argumentos
{
   RefToken exp;
}
  : exp=expressao { args.push_back( exp ); }
    (T_COMMA exp=expressao { args.push_back( exp ); } )*
  ;

literal
  : T_STRING_LIT
  | T_INT_LIT
  | T_REAL_LITERAL
  | T_CARAC_LITERAL
  | "verdadeiro"
  | "falso"
  ;

