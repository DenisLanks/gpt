/*
 *   Copyright (C) 2003-2006 by Thiago Silva                               *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */


header {
  #include "BasePortugolParser.hpp"
  #include "GPTDisplay.hpp"
  #include "GASMFE_CAsmProgram.hpp"
  #include "GASMFE_COptions.hpp"
  #include "CTemporarySymbol.hpp"
}

options {
  language="Cpp";  
}

{
}

class PortugolParser extends Parser("BasePortugolParser");

options {
  importVocab=Portugol;  // use vocab generated by lexer
  genHashLines=false;//no #line
  k=2;
}

{  
   public:
      COptions options;
      CAsmProgram  *asmPrg;
      CSubroutine *subroutine;
      CArguments args;
      CTemporarySymbol tempVar;
      CTemporarySymbol tempLabel;
      void initParser( )
      {
         options.sourcefile = "xxx.gpt";
         options.destfile   = "xxx.gasm";
         asmPrg = new CAsmProgram( &options );
         tempVar.setBaseName( "__temp_" );
         tempLabel.setBaseName( "__label_" );
      }
      void finishParser( )
      {
         delete asmPrg;
         asmPrg = NULL;
      }
}


//#########################
//## Início da gramática ##
//#########################

//##############
//## Programa ##
//##############

//--------
  programa
//-------- 
  : { initParser( ); } (declaracao_algoritmo)? (importacao)*
    (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis)* corpo EOF
    { finishParser( ); }
  ;

declaracao_algoritmo
  : "algoritmo" T_IDENTIFICADOR T_SEMICOL
  ;

importacao
  : "use" T_STRING_LIT T_SEMICOL
  ;

corpo 
  :  (declaracao_subrotina)* { subroutine = asmPrg->initSubroutine( "main" ); }
     bloco_codigo { asmPrg->finishSubroutine( subroutine ); }
     (declaracao_subrotina)*
  ;


//#############################
//## Declaração de variáveis ##
//#############################

//--------------------
  declaracao_variaveis
//--------------------
  : bloco_declaracao_variaveis
  | "variável" declaracao_variavel
  ;

bloco_declaracao_variaveis
  : "variáveis" (declaracao_variavel)+ "fim-variáveis"
  ;

declaracao_variavel
{
  RefToken tk_type;
}
  : tk_id:T_IDENTIFICADOR 
    (T_COMMA T_IDENTIFICADOR)* 
    T_COLON tipo {tk_type = lastToken; }
    (lista_inicializacao)? T_SEMICOL
    { // TODO: nao esta correto porque so gera uma variavel...
       asmPrg->emitVarDefinition( tk_id->getText( ), tk_type->getType( ) );
    }
  ;

declaracao_variavel_sing
  : T_IDENTIFICADOR T_COLON tipo (lista_inicializacao)? T_SEMICOL
  ;

tipo 
  : tipo_primitivo 
  | tipo_matriz 
  | T_IDENTIFICADOR
  ;

lista_inicializacao
  : T_ATTR (expr | inicializacao_composta)
  ;

inicializacao_composta
  : "[" (inicializacao_indices) (T_COLON inicializacao_indices)* "]"
  | "{" (inicializacao_membros) (T_COLON inicializacao_membros)* "}"
  ;

inicializacao_indices
  : (expr | inicializacao_composta)
  ;

inicializacao_membros
  : T_IDENTIFICADOR T_ATTR (expr | inicializacao_composta)
  ;

tipo_primitivo
  : "inteiro"
  | "real"
  | "caractere"
  | "literal"
  | "lógico"
  | "coringa"
  ;

tipo_matriz
  : "matriz" ("[" (T_INT_LIT)? "]")+ "do" "tipo" (tipo_primitivo | T_IDENTIFICADOR)
  ;


/****************************************************************************/
declaracao_constantes
  : bloco_declaracao_constantes
  | "constante" declaracao_constante T_SEMICOL
  ;

bloco_declaracao_constantes
  : "constantes" (declaracao_constante)+ "fim-constantes"
  ;

declaracao_constante
  : T_IDENTIFICADOR T_COLON tipo lista_inicializacao T_SEMICOL
  ;


/****************************************************************************/
bloco_declaracao_estrutura
  : "estrutura" T_IDENTIFICADOR (declaracao_variavel)+ "fim-estrutura"
  ;


/****************************************************************************/
declaracao_subrotina
  : declaracao_funcao
  | declaracao_procedimento
  ;

declaracao_funcao
//  : "função" T_IDENTIFICADOR "(" (lista_parametros)? ")" ":" tipo
  : "função" T_IDENTIFICADOR "(" ")" T_COLON tipo
    (declaracao_constantes | declaracao_variaveis)*
    bloco_codigo
  ;

declaracao_procedimento
  //: "procedimento" T_IDENTIFICADOR "(" (lista_parametros)? ")"
  : "procedimento" T_IDENTIFICADOR "(" ")"
    (declaracao_constantes | declaracao_variaveis)*
    bloco_codigo
  ;

//lista_parametros
//  : ( ("constante")? "ref")? T_IDENTIFICADOR T_COLON tipo (T_COMMA lista_parametros)*
//  ;


/****************************************************************************/
bloco_codigo
  : "início" lista_enunciados "fim"
  ;

lista_enunciados
  : (enunciado)*
  ;

enunciado
  : (lvalue T_ATTR)=> en_atribuicao
  | en_retorne
  | en_se
  | en_enquanto
//  | en_repita
  | en_para
  | en_caso
  | en_asm
  | expr
  | "sair" T_SEMICOL
  | T_SEMICOL
  ;

en_atribuicao
{
   string tklvalue;
   string tkexpret;
}
  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
//  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
//  : (lvalue T_ATTR)=> stm_attr {tkexpret=lastToken;} T_SEMICOL
    { subroutine->emitISETMn( tklvalue, tkexpret ); }
  ;

stm_attr
  : lvalue T_ATTR expr
  ;

en_retorne
  : "retorne" (expr)? T_SEMICOL
  ;

lvalue returns [string tk_id]
  : T_IDENTIFICADOR {tk_id=lastToken->getText( );} //(T_ABREC expr T_FECHAC)*
  ;

en_se
{
  string expRet;
  string elseLabel;
  string nextLabel;
}
  : "se" expRet=expr "então" { elseLabel = tempLabel.getNew( ); subroutine->emitIFNOTMn( expRet, elseLabel ); }
    lista_enunciados
    { nextLabel = tempLabel.getNew( ); subroutine->emitJMPMn( nextLabel ); }
    ("senão" { subroutine->emitLabel( elseLabel ); } lista_enunciados)? "fim-se"
    { subroutine->emitLabel( nextLabel ); }
  ;

en_enquanto
{
  string testLabel;
  string expRet;
  string nextCommandLabel;
}
  : "enquanto"
    {
       testLabel = tempLabel.getNew( );
       nextCommandLabel = tempLabel.getNew( );
       subroutine->emitLabel( testLabel );
    }
    expRet=expr "faça"
    {
       subroutine->emitIFNOTMn( expRet, nextCommandLabel );
    }
    lista_enunciados
    "fim-enquanto"
    {
       subroutine->emitJMPMn( testLabel );
       subroutine->emitLabel( nextCommandLabel );
    }
  ;

en_para
{
  string lvalueRet;
  string exp1;
  string exp2;
  string testLabel;
  string nextCommandLabel;
  string testVar;
}
  : "para" lvalueRet=lvalue "de" exp1=expr "até" exp2=expr (passo)? "faça"
    {
       subroutine->emitISETMn( lvalueRet, exp1 );
       testLabel = tempLabel.getNew( );
       nextCommandLabel = tempLabel.getNew( );
       testVar   = tempVar.getNew( );
       subroutine->emitLabel( testLabel );
       subroutine->emitMn( "ile", testVar, lvalueRet, exp2 );
       subroutine->emitIFNOTMn( testVar, nextCommandLabel );
    }
    lista_enunciados
    "fim-para"
    {
       subroutine->emitMn( "iinc", lvalueRet, "1" );
       subroutine->emitJMPMn( testLabel );
       subroutine->emitLabel( nextCommandLabel );
    }
  ;

passo
  : "passo" (T_MAIS|T_MENOS)? T_INT_LIT
  ;

//en_repita
//  : "repita" lista_enunciados "enquanto" expr
//  | "repita" lista_enunciados "até" expr
//  ;

//en_repita
//  : "repita" lista_enunciados "até" expr
//  ;

en_caso 
{
  string expret;
  string varTest;
  string nextCommandLabel;
  string nextTestLabel;
}
  : "caso" expret=expr "seja" 
    {
       varTest = tempVar.getNew( );
       subroutine->emitISETMn( varTest, expret );
       nextCommandLabel = tempLabel.getNew( );
    }
    (
       nextTestLabel=teste_caso[varTest]
       {subroutine->emitJMPMn( nextCommandLabel ); subroutine->emitLabel( nextTestLabel );}
    )+ ("senão" lista_enunciados "fim-senão")? "fim-caso" 
    {
       subroutine->emitLabel( nextCommandLabel );
    }
  ; 
  
teste_caso [string varTest] returns [string nextTestLabel]
{
  string lit;
}
  : lit=literal "faça" 
    {
       subroutine->emitMn( "ieq", tempVar.getNew( ), varTest, lit );
       nextTestLabel = tempLabel.getNew( );
       subroutine->emitIFNOTMn( tempVar.getLast( ), nextTestLabel );
    }
    lista_enunciados
    "fim-faça"
  ;

en_asm
  : "asm" (~("fim-asm"))* "fim-asm"
  ;


/****************************************************************************/
chamada_subrotina
  : tk_id:T_IDENTIFICADOR T_ABREP
    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos { args.emitMnsInSubroutineCall( ); })? T_FECHAP
    { subroutine->emitPCALLMn( tk_id->getText( ) ); }
  ; 

lista_argumentos
{
   RefToken exp;
}
  : expr { args.push_back( lastToken ); }
    (T_COMMA expr { args.push_back( lastToken ); } )*
  ;

literal returns [string ret]
  : ( T_STRING_LIT | T_INT_LIT | T_REAL_LITERAL | T_CARAC_LITERAL | "verdadeiro" | "falso" ) {ret=lastToken->getText( );}
  ;


/* ----------------------------- Expressoes ---------------------------------- */

expr returns [string ret]
  : ret=expr_e (T_KW_OU expr_e)*
  ;
  
expr_e  returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_bit_ou (T_KW_E op2=expr_bit_ou {subroutine->emitMn( "and", tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
  ;

expr_bit_ou returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  : ret=expr_bit_xou (T_BIT_OU expr_bit_xou)*
  ;

expr_bit_xou  returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  : ret=expr_bit_e (T_BIT_XOU expr_bit_e)*
  ;

expr_bit_e returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  : ret=expr_igual (T_BIT_E expr_igual)*
  ;
  
expr_igual returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  : ret=expr_relacional (T_IGUAL expr_relacional|T_DIFERENTE expr_relacional)*
  ;
        
expr_relacional returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
}
  : ret=expr_ad ((T_MAIOR| T_MAIOR_EQ| T_MENOR| T_MENOR_EQ)
    op2=expr_ad {subroutine->emitIGEMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
  ;

expr_ad returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
   string op2;
}
  : ret=expr_multip (T_MAIS op2=expr_multip {subroutine->emitISUMMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); }
                    | T_MENOS expr_multip)*
  ;

expr_multip returns [string op1]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
{
  string op2;
  RefToken op;
}
  : op1=expr_unario
    (( T_DIV | T_MULTIP | T_MOD ) {op=lastToken;} op2=expr_unario {subroutine->emitIMULMn( tempVar.getNew( ), op1, op2 ); op1=tempVar.getLast( ); } )*
  ;

expr_unario returns [string ret]
options {
  defaultErrorHandler=false; //noviable should be caught on expr
}
  : op_unario ret=expr_elemento
  ;

op_unario
  : (
        e:T_MENOS
      | a:T_MAIS
      | n:T_KW_NOT
      | b:T_BIT_NOT
    )?
  ; 

expr_elemento returns [string ret]
  : (T_IDENTIFICADOR T_ABREP)=> chamada_subrotina // ret= ???
  | ret=lvalue
  | ret=literal
  | t:T_ABREP ret=expr T_FECHAP 
  ;

