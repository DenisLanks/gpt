header {
   #include <string>
//   #include <antlr/config.hpp>
//   #include <antlr/TokenStream.hpp>
//   #include <antlr/TokenBuffer.hpp>
//   #include <antlr/LLkParser.hpp>
   #include "CSymbol.hpp"
   #include "CBindSources.hpp"
}

options {
  language="Cpp";  
}

{
}

class GptBindParser extends Parser;

options {
  importVocab=GptBindLexer;  // use vocab generated by lexer
//  genHashLines=false;//no #line
//  k=2;
}

{  
   public:
//      CGenBytecode bytecode;
      void init(std::string sourcefile)
      {
         sources = new CBindSources( sourcefile );
      }
      antlr::RefToken getLastToken()
      {
         return LT(0);
      }
      std::string getLastTokenText()
      {
         return LT(0)->getText();
      }
      std::string getCpp()
      {
         return sources->getCppSource();
      }
      std::string getHpp()
      {
         return sources->getHppSource();
      }
      std::string getMakefile()
      {
         return sources->getMakefileSource();
      }
   private:
      CBindSources *sources;
}


//####################################################################
//####################### Início da gramática ########################
//####################################################################

//###############
//## GRAMATICA ##
//###############

//-----------
  sld_grammar [std::string sourcefile]
//-----------
   : { init(sourcefile); }
     (optionsdef)?
     (headersdef)?
     {
        sources->writeHeaders();
     }
     (bindingdef)*
     {
        sources->writeFooters();
     }
     EOF
     ;

//#############
//## Options ##
//#############

//-------
  optionsdef
//-------
   : "options" T_ABREC (optiondef)* T_FECHAC
   ;

//------
  optiondef
//------
   : linkerlibOption T_SEMICOLON
   ;

///----------
   linkerlibOption
///----------
   : "linkerlib" T_EQUAL T_STRING_VALUE { sources->addLinkerLib(getLastTokenText()); }
   ;

//#############
//## Headers ##
//#############

//-------
  headersdef
//-------
   : "headers" T_ABREC (headerdef)+ T_FECHAC
   ;

//------
  headerdef
//------
   : T_STRING_VALUE {sources->addHeader(getLastTokenText());} T_SEMICOLON
   ;

//#############
//## Binding ##
//#############

//-------
  bindingdef
//-------
   : procedure_bind
   | function_bind
   ;

//--------------
  procedure_bind
//--------------
{
   std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters;
   std::vector<std::string> arguments;
}
   : "procedure" tk_procname:T_ID (parameters_declaration[parameters])
     T_MAPINTO
     tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
     {
        sources->addSubroutineBind(tk_procname->getText(), std::pair<std::string,std::string>("",""), parameters, tk_mapname->getText(), arguments);
     }
   ;

//-------------
  function_bind
//-------------
{
   std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters;
   std::vector<std::string> arguments;
   std::pair<std::string,std::string> resultType;
}
   : "function" tk_procname:T_ID (parameters_declaration[parameters]) T_COLON resultType=type
     T_MAPINTO
     tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
     {
        sources->addSubroutineBind(tk_procname->getText(), resultType, parameters, tk_mapname->getText(), arguments);
     }
   ;

///----------------------
   parameters_declaration[std::vector<std::pair<std::string, std::pair<std::string,std::string> > > &parameters]
///----------------------
{
   std::pair<std::string,std::string> typeValue;
}
   : T_ABREP
     (
        typeValue=type tk_id:T_ID
        {parameters.push_back(std::pair<std::string, std::pair<std::string,std::string> >(tk_id->getText(), typeValue));} 
        (
           T_COMMA typeValue=type tk_id2:T_ID
           {parameters.push_back(std::pair<std::string, std::pair<std::string,std::string> >(tk_id2->getText(), typeValue));} 
        )*
     )?
     T_FECHAP
   ;

///---------------------
   arguments_declaration[std::vector<std::string> &arguments]
///---------------------
   : T_ABREP
     (
        (literal|T_ID) {arguments.push_back(getLastTokenText());}
        (
           T_COMMA (literal|T_ID) {arguments.push_back(getLastTokenText());}
        )* 
     )? 
     T_FECHAP
   ;

/////---------------------
//   arguments_declaration[std::vector<std::pair<std::string, int> > &arguments]
/////---------------------
//{
//   std::string value;
//}
//   : T_ABREP
//     (
//        literal|T_ID {value=getLastTokenText();}
//        (
//           T_COMMA literal|T_ID {value=getLastTokenText();}
//        )* 
//     )? 
//     T_FECHAP
//   ;


//-------
  literal
//-------
  : ( 
        T_STRING_VALUE
      | T_INT_VALUE
      | T_REAL_VALUE
      | T_CHAR_VALUE
      | "true"
      | "false"
    ) 
  ;

///----
   type returns [std::pair<std::string,std::string> result]
///----
   :
   ( "int" {result.first = getLastTokenText();}
   | "real" {result.first = getLastTokenText();}
   | "char" {result.first = getLastTokenText();}
   | "string" {result.first = getLastTokenText();}
   | "bool" {result.first = getLastTokenText();}
   | ( "pointer" T_ABRECO tkid:T_ID T_FECHACO
      {
         result.first = "pointer";
         result.second = tkid->getText();
      } )
   | "matrix" {result.first = getLastTokenText();}
   | "data" {result.first = getLastTokenText();}
   )
   ;

/////----
//   type returns [int ret]
/////----
//   : "int"     { ret=CSymbol::INT; }
//   | "real"    { ret=CSymbol::REAL; }
//   | "char"    { ret=CSymbol::CHAR; }
//   | "string"  { ret=CSymbol::STRING; }
//   | "bool"    { ret=CSymbol::BOOL; }
//   | "pointer" { ret=CSymbol::POINTER; }
//   | "matrix"  { ret=CSymbol::MATRIX; }
//   | "data"    { ret=CSymbol::DATA; }
//   ;

